"""In-memory data structure interface."""
from abc import ABCMeta, abstractmethod

from saltyrtc.splice.splice import is_synthesized, SpliceMixin, to_untrusted
from arpeggio import ParserPython, visit_parse_tree
from saltyrtc.splice.constraints import symbolic, SymbolicVisitor


def concretize(obj, structure, constraints):
    """Used by attach_constraint() in lsm.py (see reasoning there)."""
    parser = ParserPython(symbolic, debug=False)
    parse_tree = parser.parse(constraints)
    sv = SymbolicVisitor(obj, structure, dg=False)
    visit_parse_tree(parse_tree, sv)
    return sv.constraints


class SpliceStructMixin(metaclass=ABCMeta):
    """
    Every synthesizable data structure should inherit this mixin
    class. At deletion time, Splice objects in a data structure
    that must be deleted (through synthesis) will be given concrete
    constraints that are concretized from the symbolic constraints.
    """
    def concretize_cb(self, constraints):
        """
        This method returns a callback function that will be called at
        deletion time by Splice to create concretized synthesis constraints.
        At insertion time, for each Splice* object to be inserted into
        the data structure, this method should be called with the object's
        appropriate symbolic constraints and attached the returned function
        to the object. At deletion time, the return function will be called.
        """
        # Parse the symbolic constraints provided by the developer
        parser = ParserPython(symbolic, debug=False)
        parse_tree = parser.parse(constraints)

        # The actual callback function to be attached to the Splice* object
        def concretize(obj, dg=False):
            # Concrete constraints are generated by parsing the symbolic
            # constraint and performing semantic analysis on the parsed tree.
            sv = SymbolicVisitor(obj, self, dg)
            visit_parse_tree(parse_tree, sv)
            return sv.constraints

        return concretize

    def splicify(self, data, concretize_cb):
        """
        'data' must be a Splice* object. The object is set to be untrusted and
        attached with a callback function 'concretize_cb' that will be called
        at deletion time. The callback function will concretize the symbolic
        constraints given to the object for synthesis at deletion time. Note that
        concretize_cb *can* be None if no symbolic constraints can be defined.
        """
        # assert isinstance(data, SpliceMixin), "you can only call this method " \
        #                                       "if data is of Splice* type"

        # Some data structure might be able to accept None as a valid value (e.g.,
        # value in a dictionary) or a boolean value. We cannot splicify None or
        # booleans but it is OK as long as there's no concretize_cb associated with it.
        if data is None or isinstance(data, bool):
            if concretize_cb is not None:
                raise ValueError("Cannot splificy None value with constraints.")
            else:
                return data
        # If data is not None, we should be able to splificy data
        data = to_untrusted(data)
        # TODO: If data cannot be splicified, we just return it for now
        if not isinstance(data, SpliceMixin):
            return data

        # Splice-compatible data structure must always store untrusted data;
        # this requirement is necessary because, in a Splice-compatible data
        # structure, any value can be synthesize-deleted at any quiescent moment.
        # FIXME: With to_untrusted(), this might be redundant (We comment it out now)
        # data.trusted = False
        data.constraints = concretize_cb
        return data

    @abstractmethod
    def enclosing(self, obj):
        """
        enclosing is called whenever the keyword enclosing is used in the symbolic constraints.
        Given an 'obj', which must be a Splice* object, this function should return either the
        enclosing item that is inserted into the data structure or its index. This method must
        be defined by the developers of any Splice-compatible data structure.
        """
        raise NotImplementedError("you must define the action for the enclosing keyword")


if __name__ == "__main__":
    pass
